{
    "contents" : "#' Bayesian Model Averaging\n#' \n#' Takes objects of class \\code{BMAdata} (or any of its subclasses) and runs an OLS regression for every possible combination of variables, and returns a matrix of coefficient estimates for each model, as well as the R^2 value for each model. It then runs Bayesian Model Averaging on this dataset and returns the posterior model odds, along with the posterior expected values and probability of being non-zero for each of the predictor variables supplied by the user. \n#' \n#' @param BMAdata An object of class BMAdata, which must first be created using the \"new\" function. \n#' @param g A user-supplied single numerical value. \n#' @param parallel Dummy telling R whether to run the code in parallel or not; the section of the code that runs all of the linear models can be run in parallel. By default this is set to FALSE. User must still load relevant libraries (e.g. doMC, multicore, foreach, etc.) and specify the number of cores before running the function.\n#' \n#' @return A list containing 4 elements. The first element is a matrix of coefficient estimates for each model that was run, along with the R^2 value for each of these models. The second element is a vector (really a matrix, but only one row) containing the posterior model odds for each of the OLS models that were run. The third element is also a one-row matrix containing the posterior expected values (e.g. coefficient estimates) that were derived using Bayesian Model Averaging. Finally the fourth element is a one-row matrix containing the posterior probability that each of the coefficient estimates is non-zero. \n#' @author Thomas Carroll: \\email{thomasscarroll89@gmail.com}\n#' @rdname fitBMA\n#' @examples X1 <- rnorm(100, 100, 50) \n#' X2 <- rnorm(100, 50, 10) \n#' X3 <- rnorm(100, 75, 30) \n#' Y <- 12 + 3*X1 - 6*X2 + 2*X3  + rnorm(100, 10, 5) \n#' test <- new(\"BMAdata\", depvar=Y, covariates=cbind(X1, X2, X3)) \n#' fitBMA(test)\n#' @export\nsetGeneric(\"fitBMA\", function(object=\"BMAdata\", g=3, parallel=FALSE){\n  standardGeneric(\"fitBMA\")\n})\n\n#' @export\nsetMethod(\"fitBMA\", \"BMAdata\", function(object=\"BMAdata\", g=3, parallel=FALSE){\n  library(plyr)\n  k <- ncol(object@covariates) #Let k be the number of predictor variables (not including intercept)\n  #FIRST we need to standardize the variables. I first create a generic function that will standardize a vector that is plugged into it. \n  standardize <- function(x){ #Let x be a vector of length greater than 1\n    (x - mean(x))/sd(x)\n  }\n  y.stand <- standardize(object@depvar)\n  x.stand <- apply(object@covariates, 2, standardize)\n  colnames(x.stand) <- paste(rep(\"X\", length=k), 1:k, sep=\"\") #add variable names to keep track of the variables more easily\n  \n  #SECOND we run every possible combination of linear models (none including an intercept, since we standardized the variables)\n    #2.1, we will calculate just how many linear models we need to run. The following for loop does this. \n    model.combinations <- vector(mode=\"list\") #Create object \"model.combinations\", which is a list containing all of the different combinations of variables \n    number.of.models <- c(0) #Use 0 since we don't have any models where there's just an intercept\n    for(i in 1:k){\n      model.combinations[[i]] <- combn(c(1:k), m=i)\n      number.of.models <- append(number.of.models, values=ncol(model.combinations[[i]]), after=length(number.of.models))\n    }\n    q <- sum(number.of.models) #q is just the total number of models we will need to run\n    #2.2, we'll make a quick test to ensure that the number of models we are going to run is equal to how many models we should, theoretically, have\n    q.test <- (2^k)-1\n    if(q.test!=q){\n      warning(\"Number of models being run does not equal how many models there should, theoretically, be\")\n    }\n\n  #THIRD, we run the actual models.\n    #3.1 First I create a function that will calculate a bunch of linear regressions. This makes use of the list of all possible model combinations created in step 2 above\n    my.test <- function(x){\n      #The x argument is just a matrix; in this case the function was designed to work on the list-like object model.combinations created above, so x is just one element of the list model.combinations\n      output <- matrix(NA, nrow=k+1, ncol=ncol(x))\n      count <- 0\n      for(i in 1:ncol(x)){\n        count <- count + 1\n        variable.numbers <- x[,i]\n        model <- lm(y.stand ~ x.stand[,c(variable.numbers)] - 1)\n        output[c(variable.numbers),count] <- model$coef\n        output[c(k+1),count] <- summary(model)$r.squared\n      }\n      return(output)\n    }\n    try.this <- llply(model.combinations, .fun=my.test, .parallel=parallel) #returns a list containing the coefficient estimates and R^2 values for all the models\n    #Next we have to convert the above list into a single matrix\n    try.this <- matrix(unlist(try.this), nrow=k+1, ncol=q)\n    rownames(try.this) <- c(colnames(x.stand), \"R^2\")\n    colnames(try.this) <- paste(rep(\"Model\", length=q), 1:q, sep=\" \")\n    #3.2 Next we clean up the output a little bit by doing some rounding and replacing NAs with empty character strings. \n    output.1 <- as.data.frame(try.this)\n    output.1 <- round(output.1, 4)\n    output.1[is.na(output.1)] <- \"\" # So output.1 is a matrix of coefficient estimates and R^2 values for each model\n    final.output <- list(output.1)\n    names(final.output) <- c(\"Coefficients.and.R(^2)\")\n  \n  #FOURTH, we need to calculate the posterior model odds for each model. Here we make use of the formula\n    #provided in the slides.\n  B.Mk.M0 <- numeric(length=q) #this will be the vector that we store the values of B[M_{k}:M_{0}] into for each model. See slide 25\n  n <- nrow(x.stand) #let n be the number of observations\n  for(i in 1:q){\n    p.sub.k <- sum(which(output.1[,i]!=\"\")) - 1 #this represents number of independent variables in a given model. We subtract one because the R^2 value is recorded in output.1 and we don't want to count that as an independent variable\n    r.squared.k <- as.numeric(output.1[k+1,i]) #let this represent the R^2 value in a given model\n    B.Mk.M0[i] <- ((1 + g)^((n - p.sub.k - 1)/2))*((1 + (g*(1 - r.squared.k)))^(-((n - 1)/2)))\n  }\n  posterior.model.odds <- matrix(B.Mk.M0/sum(B.Mk.M0), nrow=1) #posterior.model.odds is p(M_{k}|Y) on slide 10\n  colnames(posterior.model.odds) <-  paste(rep(\"Model\", length=q), 1:q, sep=\" \") \n  final.output[[\"posterior.model.odds\"]] <- posterior.model.odds\n  \n  #FIFTH, we need to calculate the posterior expected values for each coefficient. We use the formula on slide 26\n  expected.betas <- (g/(g + 1))*as.matrix(sapply(output.1[-c(k+1),], as.numeric)) #this returns a matrix containing the (weighted) coefficient estimates for each model\n  posterior.expected.value <- numeric(length=k)\n  for(i in 1:k){\n    model.numbers <- which(output.1[i,]!=\"\") #calculates which models a variable appears in\n    posterior.expected.value[i] <- sum(posterior.model.odds[model.numbers] * expected.betas[i,model.numbers])\n  }\n  posterior.expected.value <- matrix(posterior.expected.value, nrow=1)\n  colnames(posterior.expected.value) <- paste(rep(\"X\", k), 1:k, sep=\"\")\n  final.output[[\"posterior.expected.values\"]] <- posterior.expected.value\n  \n  #SIXTH, we need to calculate the posterior probability that each coefficient is non-zero, which we get by adding up\n  #all weight assigned to each model that includes that coefficient (i.e. the posterior.model.odds). \n  posterior.probability <- numeric(length=k)\n  for(i in 1:k){\n    model.numbers <- which(output.1[i,]!=\"\")\n    posterior.probability[i] <- sum(posterior.model.odds[model.numbers])\n  }\n  posterior.probability <- matrix(posterior.probability, nrow=1)\n  colnames(posterior.probability) <- paste(rep(\"X\", k), 1:k, sep=\"\")\n  final.output[[\"posterior.probability\"]] <- posterior.probability\n  return(final.output)\n})",
    "created" : 1395367411784.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2930467865",
    "id" : "2CB1FCCC",
    "lastKnownWriteTime" : 1395392900,
    "path" : "~/GitHub/Midterm/BMA/R/fitBMA.R",
    "project_path" : "R/fitBMA.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "source_on_save" : false,
    "type" : "r_source"
}