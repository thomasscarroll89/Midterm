{
    "contents" : "## 5: Advanced R-specific functionality for repetitive tasks\n# Stolen without apology from: http://www.ats.ucla.edu/stat/r/library/advanced_function_r.htm\n\n## 5.1:  The apply() function is a fundamental function, that is (perhaps) the least well documented functionality in all of R\n\n## apply(array, margin, function, ...)\n\n#a) An array is a data type, and can include matrices (a 2-dimensional array)\n#b) The margin argument controls how the matrix is analyzed.  Should the function by executed on each row (margin=1), each column (margin=2), etc.?\n#c) The function is what you want done on each row/column/whatever.\n#d) IMPORTANT, the ...., refers to any argument you want to pass onto the FUNCTION\n\n\nmat1 <- matrix(rep(seq(4), 4), ncol = 4)\nmat1\n\n#row sums of mat1\napply(mat1, 1, sum)\n\n#column sums of mat1\napply(mat1, 2, sum)\n\n#using a user defined function\nsum.plus.2 <- function(x){\n\tsum(x) + 2\n}\n\n#using the sum.plus.2 function on the rows of mat1\napply(mat1, 1, sum.plus.2)\n\n\n#generalizing the function to add any number to the sum\n# What is being done here?\napply(mat1, 1, function(x, y) sum(x) + y, y=3)\n\n# and here?\napply(mat1, 2, function(x, y) sum(x) + y, y=5)\n\n## Side note: My favorite error message in R\napply(mat1, 2)\n\n## 5.2: lapply()\n\n## lapply(list, function, ...)\n\n## Remember, that many of the basic objects in R are (in the end) a list.  This includes data frames.\n\nmat1.df <- data.frame(mat1)\nmat1.df\nis.list(mat1.df)\n\n#obtaining the sum of each variable in mat1.df\nlapply(mat1.df, sum)\n\n#storing the results of the lapply function in the list y\ny <- lapply(mat1.df, sum)\n\n#verifying that y is a list\nis.list(y)\nnames(y)\n\n##  Another useful application of the lapply function is with a \"dummy\n##  sequence\". The list argument is the dummy sequence and it is only\n##  used to specify how many iterations we would like to have the\n##  function executed. When the lapply functions is used in this way it\n## can replace a for loop very easily.\n\n#using the lapply function instead of the for loop\nunlist(lapply(1:5, function(i) 5+i ))\n\n#using the for loop\noutVec <- NULL\nfor(i in 1:5){\n  outVec <- c(outVec, 5+i)\n}\noutVec\n\n## 5.3: sapply()\n\n## sapply(list, function, ..., simplify)\n\n## This is a \"simplified\" version of lapply.  In fact, when simplify=FALSE, it is the same.\n\n## The key difference is that it changes what kind of object is\n## returned as a different datatype depending on what the outcome\n## looks like.\n\n## a) If the output is all scalras, the results is a vector\n## b) If the output is all vectors of the same length, it will return a matrix.\n\ny2 <- sapply(mat1.df, function(x, y) sum(x) + y, y = 5)\ny2\n## Not a list\nis.vector(y2)\nis.list(y2)\n\n\n## 5.4\n## tapply(array, indicies, function, ..., simplify)\n\n## This is less intuitive, but can be very useful for recoding tasks, handling data, etc.\n## The key here is to understand that the \"indices\" here are the values of some other object.\n\nx1 <- runif(16)\nx1\n\ncat1 <- rep(1:4, 4)\ncat1\n\ncat2 <- c(rep(1, 8), rep(2, 8))\ncat2\n\nmat2.df <- data.frame(x1)\nnames(mat2.df) <- c(\"x1\")\nmat2.df$cat1 <- cat1\nmat2.df$cat2 <- cat2\nmat2.df\n\ntapply(mat2.df$x1, INDEX = mat2.df$cat1, FUN=mean)\n\n# Compare this to:\noutVec <- NULL\nfor (i in unique(mat2.df$cat1)){\n  outVec <- c(outVec, mean(mat2.df$x1[mat2.df$cat1==i]))\n}\noutVec\n\n\n## The crazy thing, is that you can do this for combinations of values of variables\n## Four values for cat1 and two values for cat2\ntapply(mat2.df$x1, list(mat2.df$cat1, mat2.df$cat2), mean)\n\n# The first cell is the same as \nmean(mat2.df$x1[mat2.df$cat1==1 & mat2.df$cat2==1])\n\n\n## 5.6 sweep\n# sweep(array, margin, stats, function, ...)\n\n## This is used if you want to, for instance, mean center your\n## variables.  I see this used a lot, but it is not something I use as\n## much as I probably should.\n\n#creating the data set\na <- matrix(runif(100, 1, 2),20)\na.df <- data.frame(a)\n\n#subtract column means from each column\n#centering each column around mean\ncolMeans(a)\n\na1 <- sweep(a, 2, colMeans(a), \"-\")\na1[1:5,]\n\n## The column means should now be zero\ncolMeans(a1)\n\n## The name comes from the fact that the \"stats\" argument is a vector\n## of some statistic (calculated from the array) that is to be \"swept\"\n## out.  Not very intuitive.  \n\n## 5.7 by\n\n## by(data, INDICES, FUN, ..., simplify = TRUE)\n\n## by is a \"wrapper\" for tapply, that is supposed to make it easier to use.\n\n\ntapply(mat2.df$x1, INDEX = mat2.df$cat1, FUN=mean)\nbyOut <- by(data=mat2.df$x1, INDICES=mat2.df$cat1, mean)\nstr(byOut)\n\nlength(byOut)\nis.list(byOut)\nis.vector(byOut)\n\n## 5.8 vapply\n## vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)\n\nl <- list(a = 1:10, b = 11:20)\n# fivenum of values using vapply\n?fivenum\nl.fivenum <- vapply(X=l, FUN=fivenum, FUN.VALUE=c(Min.=0, \"1st Qu.\"=0, Median=0, \"3rd Qu.\"=0, Max.=0))\nclass(l.fivenum)\n\n# let's see it\nl.fivenum\n\n\n## 5.9 replicate()\n\n## replicate(n, expr, simplify = \"array\")\n\nreplicate(10, rnorm(10))\n\n## 5.10 mapply\n\n## A multivariate version of sapply.  The function is applied,\n## sequentially, to each element of each object included in the ... \n\nl1 <- list(a = c(1:10), b = c(11:20))\nl2 <- list(c = c(21:30), d = c(31:40))\nl1\nl2\n# sum the corresponding elements of l1 and l2\nmapply(sum, l1$a, l1$b, l2$c, l2$d)\n\n\n## 5.11 rapply\n## Another variant of lapply that allows for finer handling of how the output is organized\n\n## let's start with a  list example\nl <- list(a = 1:10, b = 11:20)\n## log2 of each valu\nrapply(l, log2)\nrapply(l, log2, how = \"unlist\")\nrapply(l, log2, how = \"list\")\nrapply(l, log2, how = \"replace\")\n\n\nrapply(l, mean, how=\"unlist\")\nrapply(l, mean, how = \"list\")\nrapply(l, mean, how = \"replace\")\n\n## 5.12 Other functions to be aware of\n?ave\n?colMeans\n?rowSums\n?rowsum\n?aggregate\n?replicate\n?eapply\n\n\n## 5.13 plyr package\n\n## Thy plyr package is designed to make all of this a bit easier to handle by adding the following features:\n\n## 1) Consistent naming protocols for the functions to know what you are putting in and taking out.\n## 2) Easy to make parallel.\n## 3) Built-in error recovery\n## 4) Better handling of labels\n## 5) Flexible handling of all basic data types.\n\nlibrary(plyr)\n\n# http://www.r-bloggers.com/a-fast-intro-to-plyr-for-\n\n## Let's start with a basic example\n\n#make some example data\ndd<-data.frame(matrix(rnorm(216),72,3),c(rep(\"A\",24),rep(\"B\",24),rep(\"C\",24)),c(rep(\"J\",36),rep(\"K\",36)))\ncolnames(dd) <- c(\"v1\", \"v2\", \"v3\", \"dim1\", \"dim2\")\nhead(dd)\n\n\n\n\n## The main functions we want to use are:\n# a_ply, aaply, adply, alply, d_ply, daply, ddply, dlply, l_ply, laply, llply, m_ply, maply, mdply, mlply\n\n## The first letter in each tells us what kind of input we are taking\n## a=array\n## d=data.frame\n## l=list\n## m=matrix\n\n## The second letter tells us what we want output\n## a=array\n## d=data.frame\n## l=list\n## m=matrix\n## _=discard the results\n\n\nobj1 <- ddply(.data=dd, .variables=c(\"dim1\",\"dim2\"), .fun=function(df)mean(df$v1))\nobj1\n\nobj2 <- daply(.data=dd, .variables=c(\"dim1\",\"dim2\"), .fun=function(df)mean(df$v1))\nobj2 # why are these different?\n\n## Anything you want to do is here\nl_ply(1:100, identity)\nllply(1:100, identity)\nlaply(1:100, identity)\nldply(1:100, identity)\n\n## The package has a *buch* of other useful stuff, but let's focus on ....\n\n##5.14 Going paralel with plyr\n\n## The package works seamlessly with the 'foreach' package.\n\nlibrary('doMC')\nlibrary('multicore')\nlibrary('foreach')\n\nmyX <- 20\n\nmyY <- c(1:100)\n\nmyFunction <- function(x,y){\n\n  for(i in 1:100000){\n   2+2\n  }\n  return(x+y)\n\n}\n\n\nsystem.time(out <- laply(myY, myFunction, x=myX))\n\nregisterDoMC(cores=8)\nsystem.time(out2 <- laply(myY, myFunction, x=myX, .parallel=TRUE))\n\n## This won't always be much faster\n## Note:\n?foreach\n\n## You will need to use the .paropts argument for the plyr functions\n## if your code relies on packages, code, or data that have not been\n## exported to each of the instances in the cluster.  This will be any\n## object not accessible in the current environment.\n\n\n\n##5.15 Class activity.  No loops allowed.\n\n# 1) Make a three dimensional array with dim=c(20,5, 1000) and fill it with random data.  \n## Think of this as 1000 random datasets with 20 observations and 5 covariates\n\n# 2) Here is the vector of covariates\nBeta <- matrix(c(1,2,0,4,0), ncol=1)\nBeta\n\n# Make a function to create \"Y\" values (for a linear model).  The\n# Y-values should be a linear combination of the X's plus some random\n# noise.  The output should be a 20 by 1000 array.\n\n\n#3) Run 1,000 regressions across all of this simulated data.  Have as\n#the output a 1000 by 6 matrix of estimated regression coefficients.\n\n\n#4) Create a density plot for each of the 6 coefficients (each of\n#which should have been estimated 1,000 times).\n\n# What does this represent?\n\n\n#5) Re-run that code in parallel.  How does the system time compare for the paralel version?\n\n",
    "created" : 1395392664778.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1786248416",
    "id" : "7A3D7F85",
    "lastKnownWriteTime" : 1395385149,
    "path" : "C:/Users/Thomas/Downloads/Lecture5 (3).R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}