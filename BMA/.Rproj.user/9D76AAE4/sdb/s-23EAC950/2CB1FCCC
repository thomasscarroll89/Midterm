{
    "contents" : "#' Bayesian Model Averaging\n#' \n#' Takes objects of class \\code{BMAdata} (or any of its subclasses) and runs an OLS regression for every possible combination of variables, and returns a matrix of coefficient estimates for each model, as well as the R^2 value for each model. \n#' \n#' @param BMAdata An object of class BMAdata, which must first be created using the \"new\" function. \n#' \n#' @return A matrix of coefficient estimates for each model that was run, along with the R^2 value for each of these models. \n#' @author Thomas Carroll: \\email{thomasscarroll89@gmail.com}\n#' @rdname fitBMA\n#' @export\nsetGeneric(\"fitBMA\", function(object=\"BMAdata\"){\n  standardGeneric(\"fitBMA\")\n})\n\n#' @export\nsetMethod(\"fitBMA\", \"BMAdata\", function(object=\"BMAdata\"){\n  k <- ncol(object@covariates) #Let k be the number of predictor variables (not including intercept)\n  \n  #FIRST we need to standardize the variables.\n  y.stand <- (object@depvar - mean(object@depvar))/sd(object@depvar)\n  x.stand <- matrix(NA, nrow=nrow(object@covariates), ncol=k)\n  for(i in 1:k){\n    x.stand[,i] <- (object@covariates[,i] - mean(object@covariates[,i]))/sd(object@covariates[,i])\n  }\n  colnames(x.stand) <- paste(rep(\"X\", length=k), 1:k, sep=\"\") #add variable names to keep track of the variables more easily\n  \n  #SECOND we run every possible combination of linear models (none including an intercept, since we standardized the variables)\n    #2.1, we will calculate just how many linear models we need to run. The following for loop does this. \n    model.combinations <- vector(mode=\"list\") #Create object \"model.combinations\", which is a list containing all of the different combinations of variables \n    number.of.models <- c(0) #Use 0 since we don't have any models where there's just an intercept\n    for(i in 1:k){\n      model.combinations[[i]] <- combn(c(1:k), m=i)\n      number.of.models <- append(number.of.models, values=ncol(model.combinations[[i]]), after=length(number.of.models))\n    }\n    q <- sum(number.of.models) #q is just the total number of models we will need to run\n    #2.2, we'll make a quick test to ensure that the number of models we are going to run is equal to how many models we should, theoretically, have\n    q.test <- (2^k)-1\n    if(q.test!=q){\n      warning(\"Number of models being run does not equal how many models there should, theoretically, be\")\n    }\n\n  #THIRD, we run the actual models.\n    #3.1, we create the basic structure of the output matrix\n    output2 <- matrix(NA, nrow=k+1, ncol=q)\n    rownames(output2) <- c(colnames(x.stand), \"R^2\")\n    colnames(output2) <- paste(rep(\"Model\", length=q), 1:q, sep=\" \")\n    #3.2, we run linear models. The for loops run 2^k - 1 models, one at a time. \n    count <- 0  #The \"count\" variable keeps track of which model number we are currently on; it helps when we're plugging in coefficient\n                # values and R squared values by basically telling us which column of the output matrix\n                #to plug these values into\n    for(i in 1:length(model.combinations)){\n      for(j in 1:ncol(model.combinations[[i]])){\n        count <- count + 1\n        variable.numbers <- model.combinations[[i]][,j]\n        model <- lm(y.stand ~ x.stand[,c(variable.numbers)] - 1)\n        coefficients <- model$coef\n        output2[c(variable.numbers),count] <- coefficients\n        output2[c(k+1),count] <- summary(model)$r.squared\n      }\n    }\n    #3.3 Next we clean up the output a little bit by doing some rounding and replacing NAs with empty character strings. \n    output <- as.data.frame(output2)\n    output <- round(output, 4)\n    output[is.na(output)] <- \"\"\n    return(output)\n  })",
    "created" : 1395367411784.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "616097496",
    "id" : "2CB1FCCC",
    "lastKnownWriteTime" : 1395369995,
    "path" : "~/GitHub/Midterm/BMA/R/fitBMA.R",
    "project_path" : "R/fitBMA.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "source_on_save" : false,
    "type" : "r_source"
}